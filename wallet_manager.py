"""
Wallet Management Module for Discord Rewards Platform
Handles cash deposits, withdrawals, and point conversions
"""

import logging
from datetime import datetime
from typing import Dict, Any, Optional
from decimal import Decimal
from flask_app import app
from database import db, User, WalletTransaction, UserWallet
from config import Config

logger = logging.getLogger(__name__)

class WalletManager:
    """Manages user wallet operations"""
    
    @staticmethod
    def get_or_create_wallet(user_id: str) -> UserWallet:
        """Get or create a wallet for a user"""
        wallet = UserWallet.query.filter_by(user_id=user_id).first()
        if not wallet:
            wallet = UserWallet(user_id=user_id)
            db.session.add(wallet)
            db.session.commit()
        return wallet
    
    @staticmethod
    def calculate_points_from_usd(amount_usd: float) -> Dict[str, Any]:
        """Calculate points from USD amount including bonus"""
        base_points = int(amount_usd * Config.POINTS_PER_DOLLAR)
        bonus_points = int(base_points * Config.WALLET_BONUS_PERCENTAGE)
        total_points = base_points + bonus_points
        
        return {
            'base_points': base_points,
            'bonus_points': bonus_points,
            'total_points': total_points,
            'bonus_percentage': Config.WALLET_BONUS_PERCENTAGE * 100
        }
    
    @staticmethod
    def create_deposit_transaction(user_id: str, amount_usd: float, payment_method: str = 'stripe', payment_id: str = None) -> Dict[str, Any]:
        """Create a deposit transaction"""
        try:
            # Validate amount
            if amount_usd < Config.MIN_DEPOSIT:
                return {"success": False, "error": f"Minimum deposit is ${Config.MIN_DEPOSIT}"}
            
            if amount_usd > Config.MAX_DEPOSIT:
                return {"success": False, "error": f"Maximum deposit is ${Config.MAX_DEPOSIT}"}
            
            # Calculate points
            points_calc = WalletManager.calculate_points_from_usd(amount_usd)
            
            # Create transaction record
            transaction = WalletTransaction(
                user_id=user_id,
                transaction_type='deposit',
                amount_usd=Decimal(str(amount_usd)),
                points_amount=points_calc['total_points'],
                payment_method=payment_method,
                payment_id=payment_id,
                status='pending'
            )
            db.session.add(transaction)
            db.session.commit()
            
            return {
                "success": True,
                "transaction_id": transaction.id,
                "amount_usd": amount_usd,
                "points_calculation": points_calc,
                "payment_url": f"/wallet/pay/{transaction.id}"  # This would be generated by payment processor
            }
            
        except Exception as e:
            logger.error(f"Error creating deposit transaction: {e}")
            return {"success": False, "error": "Failed to create deposit transaction"}
    
    @staticmethod
    def complete_deposit_transaction(transaction_id: int) -> Dict[str, Any]:
        """Complete a deposit transaction and add points to user"""
        try:
            transaction = WalletTransaction.query.get(transaction_id)
            if not transaction:
                return {"success": False, "error": "Transaction not found"}
            
            if transaction.status != 'pending':
                return {"success": False, "error": f"Transaction already {transaction.status}"}
            
            # Get or create user and wallet
            user = User.query.filter_by(id=transaction.user_id).first()
            if not user:
                return {"success": False, "error": "User not found"}
            
            wallet = WalletManager.get_or_create_wallet(transaction.user_id)
            
            # Add points to user
            user.points_balance += transaction.points_amount
            user.total_earned += transaction.points_amount
            
            # Update wallet stats
            wallet.total_deposited += transaction.amount_usd
            wallet.lifetime_bonus += (transaction.points_amount - int(transaction.amount_usd * Config.POINTS_PER_DOLLAR))
            wallet.last_deposit_at = datetime.utcnow()
            
            # Update transaction
            transaction.status = 'completed'
            transaction.completed_at = datetime.utcnow()
            
            db.session.commit()
            
            return {
                "success": True,
                "transaction_id": transaction.id,
                "points_added": transaction.points_amount,
                "new_balance": user.points_balance,
                "bonus_points": wallet.lifetime_bonus
            }
            
        except Exception as e:
            logger.error(f"Error completing deposit transaction: {e}")
            db.session.rollback()
            return {"success": False, "error": "Failed to complete deposit transaction"}
    
    @staticmethod
    def get_wallet_info(user_id: str) -> Dict[str, Any]:
        """Get comprehensive wallet information for a user"""
        try:
            wallet = WalletManager.get_or_create_wallet(user_id)
            user = User.query.filter_by(id=user_id).first()
            
            if not user:
                return {"success": False, "error": "User not found"}
            
            # Get recent transactions
            recent_transactions = WalletTransaction.query.filter_by(
                user_id=user_id
            ).order_by(WalletTransaction.created_at.desc()).limit(10).all()
            
            # Calculate stats
            total_deposits = WalletTransaction.query.filter_by(
                user_id=user_id, 
                transaction_type='deposit',
                status='completed'
            ).with_entities(db.func.sum(WalletTransaction.amount_usd)).scalar() or 0
            
            total_withdrawals = WalletTransaction.query.filter_by(
                user_id=user_id, 
                transaction_type='withdrawal',
                status='completed'
            ).with_entities(db.func.sum(WalletTransaction.amount_usd)).scalar() or 0
            
            return {
                "success": True,
                "wallet": {
                    "total_deposited": float(wallet.total_deposited),
                    "total_withdrawn": float(wallet.total_withdrawn),
                    "lifetime_bonus": wallet.lifetime_bonus,
                    "last_deposit": wallet.last_deposit_at.isoformat() if wallet.last_deposit_at else None,
                    "created_at": wallet.created_at.isoformat()
                },
                "user": {
                    "points_balance": user.points_balance,
                    "total_earned": user.total_earned
                },
                "stats": {
                    "total_deposits_usd": float(total_deposits),
                    "total_withdrawals_usd": float(total_withdrawals),
                    "net_deposits": float(total_deposits - total_withdrawals)
                },
                "recent_transactions": [
                    {
                        "id": t.id,
                        "type": t.transaction_type,
                        "amount_usd": float(t.amount_usd),
                        "points_amount": t.points_amount,
                        "status": t.status,
                        "created_at": t.created_at.isoformat(),
                        "payment_method": t.payment_method
                    } for t in recent_transactions
                ]
            }
            
        except Exception as e:
            logger.error(f"Error getting wallet info: {e}")
            return {"success": False, "error": "Failed to get wallet information"}
    
    @staticmethod
    def create_withdrawal_request(user_id: str, amount_usd: float, payment_method: str = 'paypal') -> Dict[str, Any]:
        """Create a withdrawal request (points to cash)"""
        try:
            # Validate amount
            if amount_usd < 10.00:  # Minimum withdrawal
                return {"success": False, "error": "Minimum withdrawal is $10.00"}
            
            # Calculate points needed
            points_needed = int(amount_usd * Config.POINTS_PER_DOLLAR)
            
            # Check user balance
            user = User.query.filter_by(id=user_id).first()
            if not user:
                return {"success": False, "error": "User not found"}
            
            if user.points_balance < points_needed:
                return {"success": False, "error": f"Insufficient points. Need {points_needed:,} points for ${amount_usd}"}
            
            # Create withdrawal transaction
            transaction = WalletTransaction(
                user_id=user_id,
                transaction_type='withdrawal',
                amount_usd=Decimal(str(amount_usd)),
                points_amount=-points_needed,  # Negative for withdrawal
                payment_method=payment_method,
                status='pending'
            )
            db.session.add(transaction)
            db.session.commit()
            
            return {
                "success": True,
                "transaction_id": transaction.id,
                "amount_usd": amount_usd,
                "points_deducted": points_needed,
                "status": "pending_approval"
            }
            
        except Exception as e:
            logger.error(f"Error creating withdrawal request: {e}")
            return {"success": False, "error": "Failed to create withdrawal request"}
    
    @staticmethod
    def get_deposit_packages() -> Dict[str, Any]:
        """Get available deposit packages with bonuses"""
        packages = []
        
        # Generate packages from $5 to $100
        amounts = [5, 10, 20, 50, 100]
        
        for amount in amounts:
            if Config.MIN_DEPOSIT <= amount <= Config.MAX_DEPOSIT:
                points_calc = WalletManager.calculate_points_from_usd(amount)
                packages.append({
                    "amount_usd": amount,
                    "base_points": points_calc['base_points'],
                    "bonus_points": points_calc['bonus_points'],
                    "total_points": points_calc['total_points'],
                    "bonus_percentage": points_calc['bonus_percentage'],
                    "value_per_dollar": points_calc['total_points'] / amount
                })
        
        return {
            "success": True,
            "packages": packages,
            "min_deposit": Config.MIN_DEPOSIT,
            "max_deposit": Config.MAX_DEPOSIT,
            "bonus_percentage": Config.WALLET_BONUS_PERCENTAGE * 100,
            "points_per_dollar": Config.POINTS_PER_DOLLAR
        }